# Discovery Interview Log

- Q1: Как одним предложением описать главную цель продукта для ваших пользователей?
  - A1: Цель фреймворка — создание полной версии технического задания, чтобы агент мог полностью автономно сделать весь цикл разработки; фреймворк задаёт вопросы и формирует всё необходимое, рассчитан на неквалифицированных пользователей, умеющих описать продукт простыми словами.
- Q2: Кто основные типы пользователей/ролей, для кого будет применяться этот фреймворк? Опиши каждую роль в 1–2 предложениях.
  - A2: Единственная роль — автор/владелец идеи продукта; он же продуктовый владелец, аналитик и бизнес-спонсор, но не разработчик. Он хорошо понимает ценность и пользовательские флоу, но слабо отвечает на технические вопросы.
- Q3: Какой конечный результат он хочет получить после прохождения фреймворка?
  - A3: Готовое приложение, которое он может проверить на соответствие ожиданиям; агент должен работать автономно (планирование, разработка, тестирование) без уточнений по мелочам.
- Q4: Какой минимальный уровень взаимодействия с агентом он готов терпеть после большого интервью?
  - A4: Идеал — полностью автономная работа без дальнейших вопросов; если по ходу возникнут неизбежные уточнения, их терпит, но рассчитывает на редкие и обоснованные случаи.
- Q5: Какие ключевые пользовательские сценарии он хочет видеть?
  - A5: Единственный сценарий — запустить фреймворк, пройти вопросы до отметки «достаточно», получить сгенерированное ТЗ, дать финальное разрешение, уйти отдыхать; фреймворк сам делает разработку/тесты/релиз и шлёт алерт о завершении или о необходимости редких уточнений.
- Q6: Как должно выглядеть финальное уведомление о завершении работы?
  - A6: Достаточно ответа прямо в текущем канале (чат или терминал), тем же тоном, что и сейчас: коротко «работа завершена, посмотри»; если нужно уточнение — задать вопрос тут же. Канал, язык, вложения или кнопки значения не имеют.
- Q7: Какие главные болячки фреймворка нужно исправить в первую очередь, чтобы считать улучшение успешным?
  - A7: Пока рано сформулировать; реальные болячки проявятся при применении фреймворка на живых хост‑проектах, тогда и станет понятно, что чинить.
- Q8: Что будет означать «успешно улучшили фреймворк» (критерии/метрики готовности)?
  - A8: В любом хост‑проекте (пустом или с legacy) фреймворк сам проведёт опрос, подготовит полноценное ТЗ, запустит агента, который выполнит разработку/тестирование/сборку приложения, и корректно завершит работу, уведомив пользователя. Такой end-to-end проход считается успехом первой итерации.
- Q9: Какие виды хост‑проектов нужно поддержать первыми и есть ли приоритет по стеку/ПААС?
  - A9: Подход задуман как общий: классический цикл «сбор требований → ТЗ → план → параллельные задачи → оркестратор». Должен одинаково работать для любых хост‑проектов (веб, мобильные, книги и др.), без привязки к стеку/ПААС; для простых проектов ожидается применимость «из коробки».
- Q10: Нужны ли обязательные ручные стоп‑точки/апрувы в процессе или ожидается полный авто‑проход?
  - A10: Ожидается полностью автономная работа. Стоп‑точки появляются только при нештатных ситуациях (недостаток информации, требуются доступы и т.п.); агент сам должен определить критерии, когда притормозить и спросить.
- Q11: Какие артефакты должны формироваться автоматически по завершении и в каком формате их потреблять?
  - A11: Базовый список артефактов уже стандартный для разработки; агент сам должен определить обязательный набор и строить вопросы/ТЗ исходя из него. Пользователь согласен с таким подходом.
- Q12: Требования к работе с доступами/секретами (хранение, каналы, шифрование/редакция)?
  - A12: Разработка идёт без кредов, пока они реально не нужны. При необходимости агент делает стоп‑точку и просит их. Секреты кладём в env‑файл; предоставляются доступы для деплоя в нужные сервисы (секреты, edge‑functions и т.п.), дальше деплой по их правилам. Требование безопасности — критично (подразумевается минимизация/редакция секретов в логах).
- Q13: Какие формы логирования и отчётности нужны (что логировать, что редактировать, в каком виде смотреть)?
  - A13: Нужны все логирующие артефакты, позволяющие эффективно отлавливать и чинить ошибки. Агент сам формирует нужные логи, баг‑репорты и отчёты (шаги оркестратора, тест‑результаты и т.д.) в подходящих форматах, чтобы по ним можно было анализировать и исправлять баги.
- Q14: Технологические предпочтения/ограничения по умолчанию?
  - A14: Базовый стек: React + Node.js + Supabase; Stripe для платежей; Tailwind. Допустимы утилиты на Python. Для WordPress проектов — PHP и сопутствующий стек. Пока фокус на этом наборе, расширение возможно позже.
- Q15: Требования к скорости/доступности (SLO) на первом этапе?
  - A15: На этапе MVP ключевое требование — полная работоспособность без ошибок и прохождение всех тестов. Цели по скорости/доступности пока не ставятся; оптимизация пойдёт после стабильной работы.
- Q16: Где разворачивать готовые приложения и сколько окружений нужно по умолчанию?
  - A16: Два основных варианта деплоя: Vercel или Netlify. (Стек — React/Node/Supabase/Stripe). О окружениях явно не указано, можно предложить стандарт dev/staging/prod.
- Q17: Какие внешние интеграции считать базовыми помимо Supabase и Stripe?
  - A17: Пока только Supabase и Stripe; дополнительно может понадобиться отправка алертов по email через Amazon SES. Остальное не добавлять на этом этапе.
- Q18: Какие данные нужны от пользователя до старта (анкеты, CSV, макеты) или собирать по ходу?
  - A18: Агент сам определяет полный объём/формат необходимых данных и спрашивает по мере нужды; пользователь ожидает, что ему скажут, что предоставить для старта.
- Q19: Формат итогового ТЗ и плана: один файл или несколько? На каком языке?
  - A19: Нужен один обзорный файл с идеей и оглавлением, ссылающийся на детальные файлы. Структура должна быть понятна и достаточна, чтобы агент мог автономно работать. (Язык не уточнён явно; по контексту — можно оставить на русском.)
- Q20: Требования к структуре параллельных задач для оркестратора?
  - A20: Достаточно карты задач, предложенной в `orchestrator-plan-ru.md`; дополнительных требований нет.
- Q21: Нужен ли отдельный независимый тест‑план/ревью-флоу для самого фреймворка или хватает текущих шаблонов?
  - A21: Такой поток уже предусмотрен: фреймворк должен сам себя анализировать (framework-review), собирать баг‑репорты от хост‑проектов в центральный репозиторий и улучшать себя. Шаблоны есть в repo; нужно использовать и следовать им.

Примечание: фреймворк обязан логировать все вопросы и ответы в этом файле.
